---
title: "Genome wide example"
output:
  #rmarkdown::html_vignette:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{genome_wide_example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(gwhap)

RESOURCE_ROOT = "<YOUR_LOCAL_RESOURCE_FS>"
```


# Installation of `gwhap`

```R
if (!require(devtools)){install.packages("devtools")}
devtools::install_github("yasmina-mekki/gwhap")
```

# Download the Rutgers genetic map

Download the Rutgers genetic map v3 (Kosambi)
```R
download_rutgers_map(RESOURCE_ROOT)
```


# Create the augmented genetic map

Create the augmented genetic map using the rutgers genetic map v3
```R
snp_physical_positions = "/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb_hap_"
rutgers_map = "/neurospin/brainomics/bio_resources/rutgers_map_v3"
output = '/neurospin/tmp/ymekki/new_repo/gwhap/augmented_genetic_map'
create_augmented_genetic_map(snp_physical_positions=snp_physical_positions, genetic_map_dir=rutgers_map, save_genetic_map=TRUE, output=output)
```

# Blocs creation

Create blocs with a single delta
```R
augmented_genetic_map_dir = '/neurospin/tmp/ymekki/new_repo/gwhap/augmented_genetic_map'
output = '/neurospin/tmp/ymekki/new_repo/gwhap/blocs'
augmented_map_df = get_augmented_genetic_map(augmented_genetic_map_dir, chromosomes=1:23)
df_blocks = create_blocks(augmented_map_df, delta=1e-3, save_blocs=TRUE, output=output)
```

# Determine the haplotypes

Set parameters :
```R
library(rlist)
library(data.table)
library(readr)

# get blocs
blocs_dir = '/neurospin/tmp/ymekki/new_repo/gwhap/blocs'
df_blocs  = get_blocs(blocs_dir)

# bgen file
bgen_file = '/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb_hap'

# phenotype
phenotype_path = '/neurospin/brainomics/2019_ln_YME/GWAS/UKB_v2/imputed_data/non_filtred/D/Putamen_d_IFGorb_d/Putamen_d_IFGorb_d.txt'
phenotype = read_delim(phenotype_path, delim='\t')

# index path
sample_semi_path = '/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb25251_hap'

# output
output = '/neurospin/tmp/ymekki/new_repo/gwhap/haplotypes'
```
The function handle one blocs at a time. In order to determine the haplotypes for the blocs created using the whole genome, we need to loop over them.
The determination of the haplotypes for 119.000 blocs is estimated to 1.5 days. In order to reduce the run time, we use the mcmapply function. Basically, this function will paralelize the process.
Please refer to the code below to implement the determination of haplotypes using all the blocs determined in the above step.

```R
for(chr in unique(df_blocs$chr)){
  
  # filtre on the chromosome
  start   = df_blocs$fromBp[df_blocs$chr == chr]
  end     = df_blocs$toBp[df_blocs$chr == chr]
  bgnfile = sprintf('%s_%s_v2.bgen', bgen_file, chr)

  # read the appropriate index file
  sample_index_file = read_delim(sprintf('%s_%s_v2_s487395.sample', sample_semi_path, chr), delim='  ')
  # get the index columns
  setDT(sample_index_file, keep.rownames = TRUE)[]
  # filtre on the phenotype IID and get the index
  samples_index = as.numeric(sample_index_file[sample_index_file$ID_2 %in% phenotype$IID, ]$rn)
  
  # get the ID that corresspond to the indexes
  bgifile = sprintf("%s.bgi", bgnfile)
  allVar = get_bgi_file(file_path = bgifile)
  dummybg = bgen.load(
    filename = bgnfile,
    data.frame(
      chromosome = '',
      start = allVar$position[1],
      end = allVar$position[1]
    ),
    max_entries_per_sample = 4
  )

  # filter the partcipant ID using their index
  mysamples = dummybg$samples[samples_index]
  
  # determine the haplotypes and binds all list elements by column
  haplotype_combined <- do.call(cbind, mcmapply(FUN     = determine_haplotypes_per_bloc,
                                               chr     = chr,
                                               start   = start,
                                               end     = end,
                                               bgnfile = bgnfile,
                                               samples_index = list(samples_index),
                                               mysamples = list(mysamples),
                                               mc.cores = 32) # number of core desired
                                               )

  # save the haplotypes
  haplotype_combined_path = sprintf('%s/haplotypes_%s.RData', output, chr)
  # Use the sparse matrix instead ...
  save(haplotype_combined, file=haplotype_combined_path, compress=T)
}
```
At then end, the haplotypes concerning one chromosome are binded by column and then saved.
Since, the test step implies that the haplotypes are tested per blocs, you need to reverse the binding process. This is done as follow :

```R
khra
```

# Test the haplotypes




