---
title: "Genome wide example"
output:
  #rmarkdown::html_vignette:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{genome_wide_example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```R
library(gwhap)

RESOURCE_ROOT = "<YOUR_LOCAL_RESOURCE_FS>"
```


# Download the Rutgers genetic map

Download the Rutgers genetic map v3 (Kosambi)
```R
download_rutgers_map(RESOURCE_ROOT)
```


# Create the augmented genetic map

Create the augmented genetic map using the rutgers genetic map v3
```R
snp_physical_positions = "/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb_hap_"
rutgers_map = "/neurospin/brainomics/bio_resources/rutgers_map_v3"
output = '/neurospin/tmp/ymekki/new_repo/gwhap/augmented_genetic_map'
create_augmented_genetic_map(snp_physical_positions=snp_physical_positions, genetic_map_dir=rutgers_map, save_genetic_map=TRUE, output=output)
```

# Blocs creation

Create blocs with a single delta
```R
augmented_genetic_map_dir = '/neurospin/tmp/ymekki/new_repo/gwhap/augmented_genetic_map'
output = '/neurospin/tmp/ymekki/new_repo/gwhap/blocs'
augmented_map_df = get_augmented_genetic_map(augmented_genetic_map_dir, chromosomes=1:23)
df_blocks = create_blocks(augmented_map_df, delta=1e-3, save_blocs=TRUE, output=output)
```

# Determine the haplotypes

Set parameters :
```R
# get blocs
blocs_dir = '/neurospin/tmp/ymekki/new_repo/gwhap/blocs'
df_blocs  = get_blocs(blocs_dir)

# bgen file
bgen_file = '/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb_hap'

# phenotype
phenotype_path = '/neurospin/brainomics/2019_ln_YME/GWAS/UKB_v2/imputed_data/non_filtred/D/Putamen_d_IFGorb_d/Putamen_d_IFGorb_d.txt'
phenotype = read_delim(phenotype_path, delim='\t')

# index path
sample_semi_path = '/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb25251_hap'

# output
output = '/neurospin/tmp/ymekki/new_repo/gwhap/haplotypes'
```
The function handle one blocs at a time. In order to determine the haplotypes for the blocs created using the whole genome, we need to loop over them.

The determination of the haplotypes for 119.000 blocs is estimated to 1.5 days. In order to reduce the run time, we use the mcmapply function. Basically, this function will paralelize the process.

Please refer to the code below to implement the determination of haplotypes using all the blocs determined in the above step.

```R
for(chr in unique(df_blocs$chr)){
  
  # filtre on the chromosome
  start   = df_blocs$fromBp[df_blocs$chr == chr]
  end     = df_blocs$toBp[df_blocs$chr == chr]
  bgnfile = sprintf('%s_%s_v2.bgen', bgen_file, chr)

  # read the appropriate index file
  sample_index_file = read_delim(sprintf('%s_%s_v2_s487395.sample', sample_semi_path, chr), delim='  ')
  # get the index columns
  setDT(sample_index_file, keep.rownames = TRUE)[]
  # filtre on the phenotype IID and get the index
  samples_index = as.numeric(sample_index_file[sample_index_file$ID_2 %in% phenotype$IID, ]$rn)
  
  # get the ID that corresspond to the indexes
  bgifile = sprintf("%s.bgi", bgnfile)
  allVar = get_bgi_file(file_path = bgifile)
  dummybg = bgen.load(
    filename = bgnfile,
    data.frame(
      chromosome = '',
      start = allVar$position[1],
      end = allVar$position[1]
    ),
    max_entries_per_sample = 4
  )

  # filter the partcipant ID using their index
  mysamples = dummybg$samples[samples_index]
  
  # determine the haplotypes and binds all list elements by column
  haplotype_combined <- do.call(cbind, mcmapply(FUN     = determine_haplotypes_per_bloc,
                                               chr     = chr,
                                               start   = start,
                                               end     = end,
                                               bgnfile = bgnfile,
                                               samples_index = list(samples_index),
                                               mysamples = list(mysamples),
                                               mc.cores = 32) # number of core desired
                                               )

  # save the haplotypes
  haplotype_combined_path = sprintf('%s/haplotypes_%s.RData', output, chr)
  # Use the sparse matrix instead ...
  save(haplotype_combined, file=haplotype_combined_path, compress=T)
}
```
At then end, the haplotypes concerning one chromosome are binded by column and then saved.

Since, the test step implies that the haplotypes are tested per blocs, you need to reverse the binding process. This is done as follow :

```R
chr = 'chr1'

# replace NA added by cbind by the chromosome code
colnames(haplotype_combined) = gsub("NA", chr, colnames(haplotype_combined))
# get the start and end bloc's position
start = unique(vapply(strsplit(colnames(haplotype_combined),"_"), `[`, 2, FUN.VALUE=character(1)))
end = unique(vapply(strsplit(colnames(haplotype_combined),"_"), `[`, 3, FUN.VALUE=character(1)))
# concatenate the start and end bloc position
blocs = sprintf('%s_%s', start, end)

# get only the haplotypes corresponding to one bloc
columns_blocs = str_subset(colnames(haplotype_combined), blocs[1])
haplotype_one_bloc = haplotype_combined[, columns_blocs]
```

# Test the haplotypes

The function is designed to handle one blocs at the time. In order to apply the three test on all haplotypes, we need to loop over them.

In order to reduce the run time, we use the mcmapply function. Basically, this function will paralelize the process.

Please refer to the code below to implement the tests using all haplotypes determined in the above step.


The haplotypes are identified by an index. You need to corespond it to the subject's ID.

* First step: get the subject's index (done by the code below)
* Second step: correspond the index to the subject's ID (done in the lm_test_haplotypes_per_bloc function)

```R
chr = "chr5"

# read index file
sample_semi_path = '/neurospin/ukb/genetic/GENETIC_DATA_500k/HAPLOTYPES/v2/ukb25251_hap'
sample_index_file = read_delim(sprintf('%s_%s_v2_s487395.sample', sample_semi_path, chr), delim='  ')

# get the index columns
setDT(sample_index_file, keep.rownames = TRUE)[]
```

Apply the test

```R
output = '/neurospin/tmp/ymekki/new_repo/gwhap/T1_subjects/lm_test'

for (i in 1:22){
  #haplotypes_path = '/neurospin/tmp/ymekki/new_repo/gwhap/RS_subjects/haplotypes/haplotypes_'
  haplotypes_path = '/neurospin/tmp/ymekki/new_repo/gwhap/T1_subjects/haplotypes/haplotypes_'
  
  load(sprintf('%schr%s.RData', haplotypes_path, i))
  #haplotype_combined
  chr = sprintf('chr%s', i)
  
  # separate the blocs
  # replace NA added by cbind by the chromosome code
  colnames(haplotype_combined) = gsub("NA", chr, colnames(haplotype_combined))
  # get the start and end bloc's position
  start = unique(vapply(strsplit(colnames(haplotype_combined),"_"), `[`, 2, FUN.VALUE=character(1)))
  end = unique(vapply(strsplit(colnames(haplotype_combined),"_"), `[`, 3, FUN.VALUE=character(1)))
  # concatenate the start and end bloc position
  blocs = sprintf('%s_%s', start, end)
  
  results_chr = mcmapply(FUN = lm_test_haplotypes_per_bloc,
                         blocs = blocs,
                         haplotype_combined = list(haplotype_combined),
                         sample_index_file = list(sample_index_file),
                         Y_filtred = list(Y_filtred),
                         mc.cores = 32)
  
  # results_chr is represented by matrix : rows representing the different test and columns representing each blocs
  # row bind the results test separetely
  bloc_test_results     = data.frame()
  complete_test_results = data.frame()
  single_test_results   = data.frame()
  for(col in colnames(results_chr)){
    bloc_test_results     = rbind(bloc_test_results, results_chr[1, col][[1]])
    complete_test_results = rbind(complete_test_results, results_chr[2, col][[1]])
    single_test_results   = rbind(single_test_results, results_chr[3, col][[1]])
  } 
  
  
  # save the results
  dir.create(sprintf('%s/chr_%s', output, i))
  write.table(bloc_test_results, sprintf('%s/chr_%s/bloc_test_results.tsv', output, i), sep="\t", row.names=FALSE)
  write.table(complete_test_results, sprintf('%s/chr_%s/complete_test_results.tsv', output, i), sep="\t", row.names=FALSE)
  write.table(single_test_results, sprintf('%s/chr_%s/single_test_results.tsv', output, i), sep="\t", row.names=FALSE)
}


lm_test_haplotypes_per_bloc = function(blocs, haplotype_combined, sample_index_file, Y_filtred){
  
  # change Y_filtred column name
  colnames(Y_filtred) = c('IID', 'phenotype')
  
  # get only the haplotypes corresponding to bloc got as input
  columns_blocs = str_subset(colnames(haplotype_combined), blocs)
  haplotype_one_bloc = haplotype_combined[, columns_blocs]
  
  # This is done in order to be sure that the subject are well alligned
  # get the index columns
  setDT(haplotype_one_bloc, keep.rownames = TRUE)[]
  # merge the index file and the haplotypes using the index
  df_tmp_merged = merge(sample_index_file, haplotype_one_bloc, by="rn")
  # merge the df obtained above with the phenotype using the ID
  df_merged = merge(df_tmp_merged, Y_filtred, by.x = 'ID_2', by.y = 'IID')
  
  # set X, Y and run the haplotypique test
  X = df_merged[, ..columns_blocs]
  Y = df_merged[, 'phenotype']
  results = lm_test_haplotypes(X, Y, kind='all')
  
  return(results)
}
```

If you need to residualise your phenotypes, please refer to this code as an example:
```R
covars_path = '/neurospin/brainomics/2019_ln_YME/covars/UKB/genetics/covar_GCTA/covar_sex_modified_GCTA_SexArray.cov'
qcovar_path = '/neurospin/brainomics/2019_ln_YME/covars/UKB/genetics/covar_GCTA/qcovar_GCTA_Age_10PCS.cov'
covars  = read_delim(covars_path, delim='\t')
qcovars = read_delim(qcovar_path, delim='\t')

cov_UKB = merge(covars, qcovars, by="IID")
cov_pheno_UKB = merge(cov_UKB, phenotype_filtred, by='IID')

X_covar = c("Array", "sex_bis", "Age", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10")
Y_pheno = c('connectivity')
X_col_name = paste(X_covar, collapse = '+')
Y_col_name = paste(Y_pheno, collapse = ',')

# linear regression
full_Lm = lapply(sprintf("cbind( %s ) ~ %s ", X_col_name, Y_col_name), lm, data = cov_pheno_UKB)
sum_Lm = lapply(full_Lm, summary)

# get the residu
Y_residualisee = data.frame(sum_Lm[[1]]$residuals)
colnames(Y_residualisee) = c('connectivity_residualisee')

Y_cov_residualisee = cbind(Y_residualisee, cov_pheno_UKB)
Y_filtred_residualisee = Y_cov_residualisee[, c('IID', 'connectivity_residualisee')]

```
